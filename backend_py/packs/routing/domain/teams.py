"""
SOLVEREIGN Routing Pack - Team Domain Model
============================================

V1 Implementation: Teams as pre-formed vehicles.
V2 Roadmap: Team Builder Solver for automatic team formation.

A Team is a resource unit for routing:
- 1-person team: Solo driver
- 2-person team: Driver pair (required for Montage, Elektro jobs)

In V1, teams are manually defined by dispatcher.
In V2, Team Builder will suggest optimal team compositions.
"""

from dataclasses import dataclass, field
from typing import List, Optional, Set
from enum import Enum
from datetime import datetime, date


class TeamType(Enum):
    """Type of team based on size and capabilities."""
    SOLO = "SOLO"           # 1 person, delivery only
    DUO_STANDARD = "DUO_STANDARD"    # 2 persons, standard montage
    DUO_ELEKTRO = "DUO_ELEKTRO"      # 2 persons, with Elektro skill
    DUO_ADVANCED = "DUO_ADVANCED"    # 2 persons, complex montage


@dataclass(frozen=True)
class TeamMember:
    """A driver assigned to a team."""
    driver_id: str
    name: str
    skills: Set[str]
    is_primary: bool = True  # Primary = driver, Secondary = helper


@dataclass
class Team:
    """
    A team is a deployable resource unit for routing.

    In V1: Manually defined by dispatcher
    In V2: Auto-generated by Team Builder
    """
    # Required fields (no defaults) - must come first
    id: str
    tenant_id: int
    plan_date: date
    members: List[TeamMember]
    team_type: TeamType
    shift_start_at: datetime
    shift_end_at: datetime
    start_depot_id: str
    end_depot_id: str

    # Optional fields with defaults - must come after required fields
    combined_skills: Set[str] = field(default_factory=set)
    capacity_volume_m3: float = 20.0
    capacity_weight_kg: float = 1000.0
    created_at: datetime = field(default_factory=datetime.utcnow)
    created_by: str = "dispatcher"  # "dispatcher" | "team_builder"
    stability_score: float = 0.0    # How often this pairing has worked together

    @property
    def team_size(self) -> int:
        return len(self.members)

    @property
    def is_two_person(self) -> bool:
        return self.team_size >= 2

    @property
    def can_do_montage(self) -> bool:
        return self.is_two_person

    @property
    def can_do_elektro(self) -> bool:
        return self.is_two_person and "ELEKTRO" in self.combined_skills

    def has_skill(self, skill: str) -> bool:
        return skill in self.combined_skills

    def to_vehicle_dict(self) -> dict:
        """
        Convert team to vehicle dict for routing solver.

        This is the bridge between Team domain and Routing domain.
        The routing solver sees teams as vehicles.
        """
        return {
            "id": self.id,
            "team_id": self.id,
            "team_size": self.team_size,
            "skills": list(self.combined_skills),
            "shift_start_at": self.shift_start_at.isoformat(),
            "shift_end_at": self.shift_end_at.isoformat(),
            "start_depot_id": self.start_depot_id,
            "end_depot_id": self.end_depot_id,
            "capacity_volume_m3": self.capacity_volume_m3,
            "capacity_weight_kg": self.capacity_weight_kg,
        }


@dataclass
class TeamRequirement:
    """
    Requirement derived from jobs/stops.

    Used by Team Builder (V2) or Dispatcher hints (V1).
    """
    min_two_person_teams: int
    min_elektro_teams: int
    min_entsorgung_teams: int
    min_montage_advanced_teams: int
    total_stops: int

    @classmethod
    def from_stops(cls, stops: List[dict]) -> "TeamRequirement":
        """
        Derive team requirements from stop list.

        This is used to show dispatcher what teams are needed.
        """
        requires_two_person = sum(1 for s in stops if s.get("requires_two_person"))
        requires_elektro = sum(1 for s in stops if "ELEKTRO" in s.get("required_skills", []))
        requires_entsorgung = sum(1 for s in stops if s.get("service_code", "").endswith("ENTSORGUNG"))
        requires_advanced = sum(1 for s in stops if "MONTAGE_ADVANCED" in s.get("required_skills", []))

        # Conservative capacity assumptions
        STOPS_PER_TEAM_MONTAGE = 4  # ~4 montage jobs per team per day
        STOPS_PER_TEAM_DELIVERY = 15  # ~15 deliveries per team per day

        # FIXED: Use ceil() instead of integer division
        # FIXED: Return 0 when demand is 0 (no max(1, ...))
        from math import ceil

        return cls(
            min_two_person_teams=ceil(requires_two_person / STOPS_PER_TEAM_MONTAGE) if requires_two_person > 0 else 0,
            min_elektro_teams=ceil(requires_elektro / STOPS_PER_TEAM_MONTAGE) if requires_elektro > 0 else 0,
            min_entsorgung_teams=ceil(requires_entsorgung / STOPS_PER_TEAM_MONTAGE) if requires_entsorgung > 0 else 0,
            min_montage_advanced_teams=ceil(requires_advanced / STOPS_PER_TEAM_MONTAGE) if requires_advanced > 0 else 0,
            total_stops=len(stops),
        )

    def to_hint_text(self) -> str:
        """Generate dispatcher hint text."""
        lines = [
            f"Empfohlene Team-Konfiguration für {self.total_stops} Stops:",
            f"  • Mindestens {self.min_two_person_teams} 2-Mann Teams",
        ]
        if self.min_elektro_teams > 0:
            lines.append(f"  • Davon {self.min_elektro_teams} mit Elektro-Skill")
        if self.min_entsorgung_teams > 0:
            lines.append(f"  • Mindestens {self.min_entsorgung_teams} für Entsorgung")
        if self.min_montage_advanced_teams > 0:
            lines.append(f"  • Mindestens {self.min_montage_advanced_teams} für komplexe Montage")
        return "\n".join(lines)


# =============================================================================
# V1 HELPER: Manual Team Creation
# =============================================================================

def create_manual_team(
    team_id: str,
    tenant_id: int,
    plan_date: date,
    driver_ids: List[str],
    driver_names: List[str],
    driver_skills: List[Set[str]],
    shift_start: datetime,
    shift_end: datetime,
    depot_id: str,
) -> Team:
    """
    Create a team manually (V1 workflow).

    Used by dispatcher to define teams before routing.
    """
    members = []
    combined_skills = set()

    for i, (did, name, skills) in enumerate(zip(driver_ids, driver_names, driver_skills)):
        members.append(TeamMember(
            driver_id=did,
            name=name,
            skills=skills,
            is_primary=(i == 0),
        ))
        combined_skills.update(skills)

    # Determine team type
    if len(members) == 1:
        team_type = TeamType.SOLO
    elif "ELEKTRO" in combined_skills:
        team_type = TeamType.DUO_ELEKTRO
    elif "MONTAGE_ADVANCED" in combined_skills:
        team_type = TeamType.DUO_ADVANCED
    else:
        team_type = TeamType.DUO_STANDARD

    return Team(
        id=team_id,
        tenant_id=tenant_id,
        plan_date=plan_date,
        members=members,
        team_type=team_type,
        combined_skills=combined_skills,
        shift_start_at=shift_start,
        shift_end_at=shift_end,
        start_depot_id=depot_id,
        end_depot_id=depot_id,
        created_by="dispatcher",
    )


# =============================================================================
# V2 ROADMAP: Team Builder Interface
# =============================================================================

class TeamBuilderResult:
    """
    Result from Team Builder (V2).

    Not implemented in V1 - placeholder for roadmap.
    """
    teams: List[Team]
    coverage_score: float  # 0-1, how well requirements are covered
    stability_score: float  # 0-1, how stable pairings are
    warnings: List[str]

    def to_dict(self) -> dict:
        return {
            "teams": [t.to_vehicle_dict() for t in self.teams],
            "coverage_score": self.coverage_score,
            "stability_score": self.stability_score,
            "warnings": self.warnings,
        }


# Placeholder for V2
def build_teams_auto(
    driver_pool: List[dict],
    requirements: TeamRequirement,
    preferences: dict = None,
) -> TeamBuilderResult:
    """
    V2 ROADMAP: Automatic team building.

    This will use a matching solver to:
    1. Cover all skill requirements
    2. Maximize pairing stability
    3. Balance workload

    NOT IMPLEMENTED IN V1.
    """
    raise NotImplementedError(
        "Automatic team building is planned for V2. "
        "In V1, use create_manual_team() with dispatcher input."
    )
