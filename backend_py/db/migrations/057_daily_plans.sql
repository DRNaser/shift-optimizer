-- =============================================================================
-- Migration 057: Daily Plan Importer + Verifier
-- =============================================================================
-- Purpose: Import daily plans from Google Sheets and verify driver assignments
--          before sending WhatsApp DMs.
--
-- Key Principle: DAILY plans from Google Sheets are trusted input.
--                Weekly plans generated by SOLVEREIGN (not manual sheets).
--
-- Verification rules:
--   - Every driver assignment must resolve to a known driver_id
--   - Driver must have consent_whatsapp = TRUE to receive DMs
--   - Duplicate phone numbers flagged
--   - Unknown drivers flagged
--
-- RLS: All tables have tenant isolation via RLS policies.
--
-- Run:
--   psql $DATABASE_URL < backend_py/db/migrations/057_daily_plans.sql
-- =============================================================================

BEGIN;

-- Record migration
INSERT INTO schema_migrations (version, description, applied_at)
VALUES ('057', 'Daily Plan Importer + Verifier', NOW())
ON CONFLICT (version) DO NOTHING;


-- =============================================================================
-- TABLE: daily_plans
-- =============================================================================
-- Imported daily plans from Google Sheets

CREATE TABLE IF NOT EXISTS masterdata.daily_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    site_id UUID REFERENCES masterdata.md_sites(id) ON DELETE SET NULL,

    -- Plan identification
    plan_date DATE NOT NULL,
    shift_type VARCHAR(50) DEFAULT 'REGULAR',  -- REGULAR, EARLY, LATE, NIGHT, SPLIT
    source_type VARCHAR(50) NOT NULL DEFAULT 'GOOGLE_SHEETS',  -- GOOGLE_SHEETS, CSV, API

    -- Import metadata
    source_url TEXT,  -- Google Sheets URL
    source_sheet_name VARCHAR(255),  -- Sheet tab name
    source_range VARCHAR(50),  -- Cell range (e.g., A1:Z100)
    import_hash CHAR(64),  -- SHA-256 of raw import for dedup

    -- Status
    status VARCHAR(30) NOT NULL DEFAULT 'DRAFT',
    -- DRAFT -> VERIFIED -> PUBLISHED | FAILED_VERIFICATION

    -- Counts
    total_assignments INTEGER DEFAULT 0,
    verified_count INTEGER DEFAULT 0,
    error_count INTEGER DEFAULT 0,

    -- Import tracking
    imported_by VARCHAR(255),  -- Email of importer
    imported_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    verified_at TIMESTAMPTZ,
    verified_by VARCHAR(255),
    published_at TIMESTAMPTZ,
    published_by VARCHAR(255),

    -- Metadata
    notes TEXT,
    metadata JSONB DEFAULT '{}',

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Constraints
    CONSTRAINT daily_plans_status_check CHECK (
        status IN ('DRAFT', 'VERIFIED', 'PUBLISHED', 'FAILED_VERIFICATION', 'CANCELLED')
    ),
    CONSTRAINT daily_plans_source_check CHECK (
        source_type IN ('GOOGLE_SHEETS', 'CSV', 'API', 'MANUAL')
    ),
    -- One plan per date/shift per site (prevent duplicates)
    CONSTRAINT daily_plans_unique_date UNIQUE (tenant_id, site_id, plan_date, shift_type)
);

CREATE INDEX IF NOT EXISTS idx_daily_plans_tenant ON masterdata.daily_plans(tenant_id);
CREATE INDEX IF NOT EXISTS idx_daily_plans_date ON masterdata.daily_plans(plan_date DESC);
CREATE INDEX IF NOT EXISTS idx_daily_plans_status ON masterdata.daily_plans(tenant_id, status);
CREATE INDEX IF NOT EXISTS idx_daily_plans_site ON masterdata.daily_plans(site_id, plan_date);

COMMENT ON TABLE masterdata.daily_plans IS
'Imported daily plans from Google Sheets. Source of truth for daily shift assignments.';


-- =============================================================================
-- TABLE: daily_plan_assignments
-- =============================================================================
-- Individual driver assignments within a daily plan

CREATE TABLE IF NOT EXISTS masterdata.daily_plan_assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    daily_plan_id UUID NOT NULL REFERENCES masterdata.daily_plans(id) ON DELETE CASCADE,

    -- Raw import data (as received from Google Sheets)
    raw_driver_name VARCHAR(255),
    raw_driver_id VARCHAR(255),  -- External ID from sheet
    raw_phone VARCHAR(50),  -- Phone as entered in sheet
    raw_shift_start VARCHAR(20),  -- Time as string
    raw_shift_end VARCHAR(20),
    raw_tour_id VARCHAR(100),
    raw_vehicle_id VARCHAR(100),
    raw_notes TEXT,

    -- Resolved references
    driver_id UUID,  -- Resolved canonical driver UUID
    driver_contact_id UUID REFERENCES masterdata.driver_contacts(id),
    tour_id UUID,  -- Resolved tour ID
    vehicle_id UUID REFERENCES masterdata.md_vehicles(id),

    -- Parsed shift times
    shift_start TIME,
    shift_end TIME,
    shift_duration_hours NUMERIC(4,2),

    -- Verification status
    verification_status VARCHAR(30) NOT NULL DEFAULT 'PENDING',
    -- PENDING -> VERIFIED | FAILED | PARTIAL
    verification_errors TEXT[],  -- Array of error codes
    verification_warnings TEXT[],  -- Array of warning codes
    verified_at TIMESTAMPTZ,

    -- DM status
    dm_eligible BOOLEAN DEFAULT FALSE,  -- Can receive DM (consent + valid phone)
    dm_queued_at TIMESTAMPTZ,
    dm_id UUID REFERENCES notify.dm_queue(id),

    -- Row metadata
    row_number INTEGER,  -- Original row in sheet
    row_hash CHAR(64),  -- Hash of raw values for change detection

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Constraints
    CONSTRAINT assignments_verification_check CHECK (
        verification_status IN ('PENDING', 'VERIFIED', 'FAILED', 'PARTIAL', 'SKIPPED')
    )
);

CREATE INDEX IF NOT EXISTS idx_assignments_plan ON masterdata.daily_plan_assignments(daily_plan_id);
CREATE INDEX IF NOT EXISTS idx_assignments_driver ON masterdata.daily_plan_assignments(driver_id);
CREATE INDEX IF NOT EXISTS idx_assignments_status ON masterdata.daily_plan_assignments(verification_status);
CREATE INDEX IF NOT EXISTS idx_assignments_dm ON masterdata.daily_plan_assignments(dm_eligible)
    WHERE dm_eligible = TRUE;

COMMENT ON TABLE masterdata.daily_plan_assignments IS
'Individual driver assignments within a daily plan. Verified before DM sending.';


-- =============================================================================
-- TABLE: verification_reports
-- =============================================================================
-- Detailed verification reports for daily plans

CREATE TABLE IF NOT EXISTS masterdata.verification_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id INTEGER NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    daily_plan_id UUID NOT NULL REFERENCES masterdata.daily_plans(id) ON DELETE CASCADE,

    -- Report summary
    report_type VARCHAR(50) NOT NULL DEFAULT 'PRE_PUBLISH',  -- PRE_PUBLISH, POST_IMPORT
    generated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    generated_by VARCHAR(255),

    -- Counts
    total_assignments INTEGER NOT NULL,
    verified_count INTEGER NOT NULL DEFAULT 0,
    failed_count INTEGER NOT NULL DEFAULT 0,
    warning_count INTEGER NOT NULL DEFAULT 0,
    dm_eligible_count INTEGER NOT NULL DEFAULT 0,
    dm_blocked_count INTEGER NOT NULL DEFAULT 0,

    -- Error breakdown
    missing_driver_id_count INTEGER DEFAULT 0,
    unknown_driver_count INTEGER DEFAULT 0,
    duplicate_phone_count INTEGER DEFAULT 0,
    missing_consent_count INTEGER DEFAULT 0,
    invalid_phone_count INTEGER DEFAULT 0,

    -- Detailed results (for UI display)
    details JSONB DEFAULT '[]',  -- Array of assignment results
    -- [{assignment_id, driver_name, status, errors, warnings}]

    -- Recommendation
    can_publish BOOLEAN DEFAULT FALSE,  -- Safe to publish?
    blocking_issues TEXT[],  -- Issues that block publishing
    non_blocking_issues TEXT[],  -- Warnings

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_verification_reports_plan ON masterdata.verification_reports(daily_plan_id);
CREATE INDEX IF NOT EXISTS idx_verification_reports_date ON masterdata.verification_reports(generated_at DESC);

COMMENT ON TABLE masterdata.verification_reports IS
'Verification reports for daily plan imports. Shows driver resolution and consent status.';


-- =============================================================================
-- ENABLE RLS
-- =============================================================================

ALTER TABLE masterdata.daily_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE masterdata.daily_plans FORCE ROW LEVEL SECURITY;

ALTER TABLE masterdata.daily_plan_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE masterdata.daily_plan_assignments FORCE ROW LEVEL SECURITY;

ALTER TABLE masterdata.verification_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE masterdata.verification_reports FORCE ROW LEVEL SECURITY;


-- =============================================================================
-- RLS POLICIES
-- =============================================================================

CREATE POLICY daily_plans_tenant ON masterdata.daily_plans
    FOR ALL
    USING (tenant_id = current_setting('app.current_tenant_id', TRUE)::INTEGER)
    WITH CHECK (tenant_id = current_setting('app.current_tenant_id', TRUE)::INTEGER);

CREATE POLICY assignments_tenant ON masterdata.daily_plan_assignments
    FOR ALL
    USING (tenant_id = current_setting('app.current_tenant_id', TRUE)::INTEGER)
    WITH CHECK (tenant_id = current_setting('app.current_tenant_id', TRUE)::INTEGER);

CREATE POLICY reports_tenant ON masterdata.verification_reports
    FOR ALL
    USING (tenant_id = current_setting('app.current_tenant_id', TRUE)::INTEGER)
    WITH CHECK (tenant_id = current_setting('app.current_tenant_id', TRUE)::INTEGER);


-- =============================================================================
-- GRANTS
-- =============================================================================

DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'solvereign_api') THEN
        GRANT SELECT, INSERT, UPDATE ON masterdata.daily_plans TO solvereign_api;
        GRANT SELECT, INSERT, UPDATE ON masterdata.daily_plan_assignments TO solvereign_api;
        GRANT SELECT, INSERT ON masterdata.verification_reports TO solvereign_api;
    END IF;

    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'solvereign_platform') THEN
        GRANT ALL ON masterdata.daily_plans TO solvereign_platform;
        GRANT ALL ON masterdata.daily_plan_assignments TO solvereign_platform;
        GRANT ALL ON masterdata.verification_reports TO solvereign_platform;
    END IF;
END $$;


-- =============================================================================
-- TRIGGERS
-- =============================================================================

CREATE TRIGGER tr_daily_plans_updated_at
    BEFORE UPDATE ON masterdata.daily_plans
    FOR EACH ROW EXECUTE FUNCTION masterdata.update_updated_at();

CREATE TRIGGER tr_assignments_updated_at
    BEFORE UPDATE ON masterdata.daily_plan_assignments
    FOR EACH ROW EXECUTE FUNCTION masterdata.update_updated_at();


-- =============================================================================
-- FUNCTION: verify_daily_plan_assignment
-- =============================================================================
-- Verify a single assignment and resolve driver references

CREATE OR REPLACE FUNCTION masterdata.verify_daily_plan_assignment(
    p_assignment_id UUID
)
RETURNS JSONB AS $$
DECLARE
    v_assignment RECORD;
    v_errors TEXT[] := ARRAY[]::TEXT[];
    v_warnings TEXT[] := ARRAY[]::TEXT[];
    v_driver_id UUID;
    v_driver_contact_id UUID;
    v_contact_check JSONB;
    v_status VARCHAR;
    v_dm_eligible BOOLEAN := FALSE;
BEGIN
    -- Get assignment
    SELECT * INTO v_assignment
    FROM masterdata.daily_plan_assignments
    WHERE id = p_assignment_id;

    IF NOT FOUND THEN
        RETURN jsonb_build_object('error', 'ASSIGNMENT_NOT_FOUND');
    END IF;

    -- Step 1: Try to resolve driver_id from raw_driver_id
    IF v_assignment.raw_driver_id IS NOT NULL AND v_assignment.raw_driver_id != '' THEN
        -- Try masterdata external mapping
        v_driver_id := masterdata.resolve_external_id(
            v_assignment.tenant_id, 'google_sheets', 'driver', v_assignment.raw_driver_id
        );

        IF v_driver_id IS NULL THEN
            v_errors := array_append(v_errors, 'DRIVER_NOT_IN_MDL');
        END IF;
    ELSE
        v_errors := array_append(v_errors, 'MISSING_DRIVER_ID');
    END IF;

    -- Step 2: If driver found, get contact and verify consent
    IF v_driver_id IS NOT NULL THEN
        SELECT id INTO v_driver_contact_id
        FROM masterdata.driver_contacts
        WHERE tenant_id = v_assignment.tenant_id
          AND driver_id = v_driver_id;

        IF v_driver_contact_id IS NULL THEN
            v_errors := array_append(v_errors, 'NO_DRIVER_CONTACT');
        ELSE
            -- Check consent
            v_contact_check := masterdata.verify_contact_for_dm(v_assignment.tenant_id, v_driver_id);

            IF (v_contact_check->>'can_send')::BOOLEAN THEN
                v_dm_eligible := TRUE;
            ELSE
                -- Add consent errors as warnings (not blocking for verification)
                IF v_contact_check->'errors' ? 'NO_WHATSAPP_CONSENT' THEN
                    v_warnings := array_append(v_warnings, 'MISSING_CONSENT');
                END IF;
                IF v_contact_check->'errors' ? 'DRIVER_OPTED_OUT' THEN
                    v_warnings := array_append(v_warnings, 'OPTED_OUT');
                END IF;
                IF v_contact_check->'errors' ? 'NO_PHONE_NUMBER' THEN
                    v_errors := array_append(v_errors, 'NO_PHONE_NUMBER');
                END IF;
            END IF;
        END IF;
    END IF;

    -- Step 3: Validate phone format if raw_phone provided
    IF v_assignment.raw_phone IS NOT NULL AND v_assignment.raw_phone != '' THEN
        IF NOT masterdata.validate_e164_phone(
            masterdata.normalize_to_e164(v_assignment.raw_phone)
        ) THEN
            v_errors := array_append(v_errors, 'INVALID_PHONE_FORMAT');
        END IF;
    END IF;

    -- Determine final status
    IF array_length(v_errors, 1) IS NULL THEN
        v_status := 'VERIFIED';
    ELSIF array_length(v_errors, 1) > 0 AND array_length(v_warnings, 1) > 0 THEN
        v_status := 'PARTIAL';
    ELSE
        v_status := 'FAILED';
    END IF;

    -- Update assignment
    UPDATE masterdata.daily_plan_assignments
    SET
        driver_id = v_driver_id,
        driver_contact_id = v_driver_contact_id,
        verification_status = v_status,
        verification_errors = v_errors,
        verification_warnings = v_warnings,
        verified_at = NOW(),
        dm_eligible = v_dm_eligible,
        updated_at = NOW()
    WHERE id = p_assignment_id;

    RETURN jsonb_build_object(
        'assignment_id', p_assignment_id,
        'status', v_status,
        'driver_id', v_driver_id,
        'dm_eligible', v_dm_eligible,
        'errors', v_errors,
        'warnings', v_warnings
    );
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION masterdata.verify_daily_plan_assignment IS
'Verify a single daily plan assignment. Resolves driver ID and checks consent.';


-- =============================================================================
-- FUNCTION: verify_daily_plan
-- =============================================================================
-- Verify all assignments in a daily plan and generate report

CREATE OR REPLACE FUNCTION masterdata.verify_daily_plan(
    p_daily_plan_id UUID,
    p_verified_by VARCHAR DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    v_plan RECORD;
    v_assignment RECORD;
    v_result JSONB;
    v_results JSONB[] := ARRAY[]::JSONB[];
    v_report_id UUID;

    -- Counters
    v_total INTEGER := 0;
    v_verified INTEGER := 0;
    v_failed INTEGER := 0;
    v_warnings INTEGER := 0;
    v_dm_eligible INTEGER := 0;
    v_dm_blocked INTEGER := 0;

    -- Error breakdown
    v_missing_driver_id INTEGER := 0;
    v_unknown_driver INTEGER := 0;
    v_duplicate_phone INTEGER := 0;
    v_missing_consent INTEGER := 0;
    v_invalid_phone INTEGER := 0;

    -- Blocking issues
    v_blocking_issues TEXT[] := ARRAY[]::TEXT[];
    v_can_publish BOOLEAN := TRUE;
BEGIN
    -- Get plan
    SELECT * INTO v_plan
    FROM masterdata.daily_plans
    WHERE id = p_daily_plan_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Daily plan not found: %', p_daily_plan_id;
    END IF;

    -- Verify each assignment
    FOR v_assignment IN
        SELECT id FROM masterdata.daily_plan_assignments
        WHERE daily_plan_id = p_daily_plan_id
        ORDER BY row_number
    LOOP
        v_total := v_total + 1;
        v_result := masterdata.verify_daily_plan_assignment(v_assignment.id);
        v_results := array_append(v_results, v_result);

        -- Count results
        CASE v_result->>'status'
            WHEN 'VERIFIED' THEN v_verified := v_verified + 1;
            WHEN 'FAILED' THEN v_failed := v_failed + 1;
            WHEN 'PARTIAL' THEN v_warnings := v_warnings + 1;
        END CASE;

        IF (v_result->>'dm_eligible')::BOOLEAN THEN
            v_dm_eligible := v_dm_eligible + 1;
        ELSE
            v_dm_blocked := v_dm_blocked + 1;
        END IF;

        -- Count error types
        IF v_result->'errors' ? 'MISSING_DRIVER_ID' THEN
            v_missing_driver_id := v_missing_driver_id + 1;
        END IF;
        IF v_result->'errors' ? 'DRIVER_NOT_IN_MDL' THEN
            v_unknown_driver := v_unknown_driver + 1;
        END IF;
        IF v_result->'warnings' ? 'MISSING_CONSENT' THEN
            v_missing_consent := v_missing_consent + 1;
        END IF;
        IF v_result->'errors' ? 'INVALID_PHONE_FORMAT' THEN
            v_invalid_phone := v_invalid_phone + 1;
        END IF;
    END LOOP;

    -- Check for duplicate phones
    SELECT COUNT(*) INTO v_duplicate_phone
    FROM (
        SELECT raw_phone
        FROM masterdata.daily_plan_assignments
        WHERE daily_plan_id = p_daily_plan_id
          AND raw_phone IS NOT NULL
          AND raw_phone != ''
        GROUP BY raw_phone
        HAVING COUNT(*) > 1
    ) dups;

    -- Determine blocking issues
    IF v_failed > 0 THEN
        v_blocking_issues := array_append(v_blocking_issues,
            format('%s assignments failed verification', v_failed));
        v_can_publish := FALSE;
    END IF;

    IF v_missing_driver_id > 0 THEN
        v_blocking_issues := array_append(v_blocking_issues,
            format('%s assignments missing driver ID', v_missing_driver_id));
        v_can_publish := FALSE;
    END IF;

    IF v_unknown_driver > 0 THEN
        v_blocking_issues := array_append(v_blocking_issues,
            format('%s unknown drivers (not in MDL)', v_unknown_driver));
        v_can_publish := FALSE;
    END IF;

    -- Create verification report
    INSERT INTO masterdata.verification_reports (
        tenant_id, daily_plan_id, report_type, generated_by,
        total_assignments, verified_count, failed_count, warning_count,
        dm_eligible_count, dm_blocked_count,
        missing_driver_id_count, unknown_driver_count, duplicate_phone_count,
        missing_consent_count, invalid_phone_count,
        details, can_publish, blocking_issues
    ) VALUES (
        v_plan.tenant_id, p_daily_plan_id, 'PRE_PUBLISH', p_verified_by,
        v_total, v_verified, v_failed, v_warnings,
        v_dm_eligible, v_dm_blocked,
        v_missing_driver_id, v_unknown_driver, v_duplicate_phone,
        v_missing_consent, v_invalid_phone,
        to_jsonb(v_results), v_can_publish, v_blocking_issues
    )
    RETURNING id INTO v_report_id;

    -- Update plan status
    UPDATE masterdata.daily_plans
    SET
        status = CASE WHEN v_can_publish THEN 'VERIFIED' ELSE 'FAILED_VERIFICATION' END,
        verified_count = v_verified,
        error_count = v_failed,
        verified_at = NOW(),
        verified_by = p_verified_by,
        updated_at = NOW()
    WHERE id = p_daily_plan_id;

    RETURN v_report_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION masterdata.verify_daily_plan IS
'Verify all assignments in a daily plan. Returns report ID with detailed results.';


-- =============================================================================
-- FUNCTION: check_dm_eligibility_bulk
-- =============================================================================
-- Check DM eligibility for multiple drivers (batch operation)

CREATE OR REPLACE FUNCTION masterdata.check_dm_eligibility_bulk(
    p_daily_plan_id UUID
)
RETURNS TABLE (
    assignment_id UUID,
    driver_id UUID,
    driver_name VARCHAR,
    dm_eligible BOOLEAN,
    block_reason VARCHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.id,
        a.driver_id,
        COALESCE(dc.display_name, a.raw_driver_name)::VARCHAR,
        CASE
            WHEN a.driver_id IS NULL THEN FALSE
            WHEN dc.id IS NULL THEN FALSE
            WHEN NOT dc.consent_whatsapp THEN FALSE
            WHEN dc.opt_out_at IS NOT NULL THEN FALSE
            WHEN dc.status != 'active' THEN FALSE
            ELSE TRUE
        END AS dm_eligible,
        CASE
            WHEN a.driver_id IS NULL THEN 'DRIVER_NOT_RESOLVED'
            WHEN dc.id IS NULL THEN 'NO_CONTACT_RECORD'
            WHEN NOT dc.consent_whatsapp THEN 'NO_CONSENT'
            WHEN dc.opt_out_at IS NOT NULL THEN 'OPTED_OUT'
            WHEN dc.status != 'active' THEN 'DRIVER_INACTIVE'
            ELSE NULL
        END::VARCHAR AS block_reason
    FROM masterdata.daily_plan_assignments a
    LEFT JOIN masterdata.driver_contacts dc
        ON dc.tenant_id = a.tenant_id AND dc.driver_id = a.driver_id
    WHERE a.daily_plan_id = p_daily_plan_id;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION masterdata.check_dm_eligibility_bulk IS
'Check DM eligibility for all assignments in a daily plan. Returns block reasons.';


-- =============================================================================
-- FUNCTION: import_daily_plan_row
-- =============================================================================
-- Import a single row into a daily plan (used by importer)

CREATE OR REPLACE FUNCTION masterdata.import_daily_plan_row(
    p_daily_plan_id UUID,
    p_row_number INTEGER,
    p_raw_driver_name VARCHAR,
    p_raw_driver_id VARCHAR,
    p_raw_phone VARCHAR DEFAULT NULL,
    p_raw_shift_start VARCHAR DEFAULT NULL,
    p_raw_shift_end VARCHAR DEFAULT NULL,
    p_raw_tour_id VARCHAR DEFAULT NULL,
    p_raw_vehicle_id VARCHAR DEFAULT NULL,
    p_raw_notes TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    v_plan RECORD;
    v_assignment_id UUID;
    v_row_hash CHAR(64);
BEGIN
    -- Get plan
    SELECT * INTO v_plan
    FROM masterdata.daily_plans
    WHERE id = p_daily_plan_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Daily plan not found: %', p_daily_plan_id;
    END IF;

    -- Calculate row hash for change detection
    v_row_hash := encode(sha256(
        (COALESCE(p_raw_driver_name, '') || '|' ||
         COALESCE(p_raw_driver_id, '') || '|' ||
         COALESCE(p_raw_phone, '') || '|' ||
         COALESCE(p_raw_shift_start, '') || '|' ||
         COALESCE(p_raw_shift_end, ''))::bytea
    ), 'hex');

    -- Insert assignment
    INSERT INTO masterdata.daily_plan_assignments (
        tenant_id, daily_plan_id, row_number, row_hash,
        raw_driver_name, raw_driver_id, raw_phone,
        raw_shift_start, raw_shift_end, raw_tour_id,
        raw_vehicle_id, raw_notes,
        verification_status
    ) VALUES (
        v_plan.tenant_id, p_daily_plan_id, p_row_number, v_row_hash,
        p_raw_driver_name, p_raw_driver_id, p_raw_phone,
        p_raw_shift_start, p_raw_shift_end, p_raw_tour_id,
        p_raw_vehicle_id, p_raw_notes,
        'PENDING'
    )
    RETURNING id INTO v_assignment_id;

    -- Update plan count
    UPDATE masterdata.daily_plans
    SET
        total_assignments = total_assignments + 1,
        updated_at = NOW()
    WHERE id = p_daily_plan_id;

    RETURN v_assignment_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION masterdata.import_daily_plan_row IS
'Import a single row from Google Sheets into a daily plan.';


-- =============================================================================
-- VERIFICATION FUNCTION
-- =============================================================================

CREATE OR REPLACE FUNCTION masterdata.verify_daily_plans_integrity()
RETURNS TABLE (
    check_name TEXT,
    status TEXT,
    details TEXT
) AS $$
BEGIN
    -- Check 1: RLS enabled on daily_plans
    RETURN QUERY
    SELECT
        'rls_daily_plans'::TEXT,
        CASE WHEN relrowsecurity AND relforcerowsecurity THEN 'PASS' ELSE 'FAIL' END,
        'daily_plans has RLS enabled'::TEXT
    FROM pg_class WHERE oid = 'masterdata.daily_plans'::regclass;

    -- Check 2: RLS enabled on assignments
    RETURN QUERY
    SELECT
        'rls_assignments'::TEXT,
        CASE WHEN relrowsecurity AND relforcerowsecurity THEN 'PASS' ELSE 'FAIL' END,
        'daily_plan_assignments has RLS enabled'::TEXT
    FROM pg_class WHERE oid = 'masterdata.daily_plan_assignments'::regclass;

    -- Check 3: RLS enabled on reports
    RETURN QUERY
    SELECT
        'rls_reports'::TEXT,
        CASE WHEN relrowsecurity AND relforcerowsecurity THEN 'PASS' ELSE 'FAIL' END,
        'verification_reports has RLS enabled'::TEXT
    FROM pg_class WHERE oid = 'masterdata.verification_reports'::regclass;

    -- Check 4: Unique constraint exists
    RETURN QUERY
    SELECT
        'unique_constraint'::TEXT,
        CASE WHEN EXISTS (
            SELECT 1 FROM pg_constraint WHERE conname = 'daily_plans_unique_date'
        ) THEN 'PASS' ELSE 'FAIL' END,
        'Unique constraint on (tenant, site, date, shift) exists'::TEXT;

    -- Check 5: No orphaned assignments
    RETURN QUERY
    SELECT
        'no_orphaned_assignments'::TEXT,
        CASE WHEN COUNT(*) = 0 THEN 'PASS' ELSE 'FAIL' END,
        format('%s orphaned assignments', COUNT(*))::TEXT
    FROM masterdata.daily_plan_assignments a
    LEFT JOIN masterdata.daily_plans p ON p.id = a.daily_plan_id
    WHERE p.id IS NULL;

    -- Check 6: Functions exist
    RETURN QUERY
    SELECT
        'functions_exist'::TEXT,
        CASE WHEN COUNT(*) >= 4 THEN 'PASS' ELSE 'FAIL' END,
        format('%s/4 daily plan functions exist', COUNT(*))::TEXT
    FROM pg_proc pr
    JOIN pg_namespace n ON pr.pronamespace = n.oid
    WHERE n.nspname = 'masterdata'
      AND pr.proname IN (
          'verify_daily_plan_assignment', 'verify_daily_plan',
          'check_dm_eligibility_bulk', 'import_daily_plan_row'
      );

END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION masterdata.verify_daily_plans_integrity IS
'Verify daily plans schema integrity.';


-- =============================================================================
-- SUCCESS MESSAGE
-- =============================================================================

DO $$
BEGIN
    RAISE NOTICE '============================================================';
    RAISE NOTICE 'Migration 057: Daily Plan Importer + Verifier COMPLETE';
    RAISE NOTICE '============================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'TABLES:';
    RAISE NOTICE '  - masterdata.daily_plans (imported plans)';
    RAISE NOTICE '  - masterdata.daily_plan_assignments (driver assignments)';
    RAISE NOTICE '  - masterdata.verification_reports (verification results)';
    RAISE NOTICE '';
    RAISE NOTICE 'FUNCTIONS:';
    RAISE NOTICE '  - verify_daily_plan_assignment(assignment_id)';
    RAISE NOTICE '  - verify_daily_plan(plan_id) -> report_id';
    RAISE NOTICE '  - check_dm_eligibility_bulk(plan_id)';
    RAISE NOTICE '  - import_daily_plan_row(plan_id, row_data...)';
    RAISE NOTICE '';
    RAISE NOTICE 'VERIFICATION ERRORS:';
    RAISE NOTICE '  - MISSING_DRIVER_ID: No driver ID in source';
    RAISE NOTICE '  - DRIVER_NOT_IN_MDL: Driver not in master data';
    RAISE NOTICE '  - NO_DRIVER_CONTACT: No contact record for driver';
    RAISE NOTICE '  - MISSING_CONSENT: No WhatsApp consent';
    RAISE NOTICE '  - INVALID_PHONE_FORMAT: Phone not E.164';
    RAISE NOTICE '';
    RAISE NOTICE 'VERIFY:';
    RAISE NOTICE '  SELECT * FROM masterdata.verify_daily_plans_integrity();';
    RAISE NOTICE '============================================================';
END $$;

COMMIT;
